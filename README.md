**Рекомендация:**  
Смотреть следует только лабораторные работы **№6–№8**; остальные либо скучные, либо выполнены неаккуратно и представляют меньше практической ценности.


### Лабораторная №1 — Анализ access.log

**Цель:**  
Реализовать консольную утилиту для анализа логов веб-сервера (access.log), способную находить ошибки (5XX) и определять периоды максимальной активности запросов.

**Содержание:**  
- Разработка программы, обрабатывающей файл логов без зависимости от его размера.  
- Реализация фильтрации запросов по статусу и временным промежуткам.  
- Добавление опций командной строки для вывода результатов и статистики.  
- Определение интервала времени с максимальным количеством запросов.  
- Использование только стандартной библиотеки C++.  


### Лабораторная №2 — ITMO Endian (`uint239_t`)

**Цель:**  
Спроектировать и реализовать собственный беззнаковый целочисленный тип `uint239_t` размером 35 байт в формате ITMO-endian (каждый байт содержит 7 значимых бит и 1 служебный бит), обеспечив корректную работу арифметических операций и вывода с учётом механики сдвига.

**Содержание:**  
- Описание структуры числа в формате ITMO-endian (35 байт, 239 значимых бит, 35 служебных бит, 6 padding-бит).  
- Реализация типа `uint239_t` в файлах `lib/number.h` и `lib/number.cpp`.  
- Конвертация из `uint32_t` и из строки.  
- Реализация операций: сложение, вычитание, а также умножение и деление.  
- Расчёт сдвига (служебные биты): сумма сдвигов при сложении/умножении, разность — при вычитании/делении.  
- Перегрузка операторов: `+`, `-`, `*`, `/`, `==`, `!=`, а также вывод в поток и получение сдвига.  
- Соблюдение ограничений: без использования стандартных контейнеров (`std::vector`, `std::bitset` и др.).  
- Проверка корректности реализации через тесты (`number_tests`).


  ### Лабораторная №3 — Модель песчаной кучи

**Цель:**  
Смоделировать песчаную кучу с возможностью сохранения состояний в формате BMP.

**Содержание:**  
- Чтение начального состояния из TSV-файла (`x`, `y`, `count`).  
- Динамическое изменение размера сетки при «обвале» песчинок.  
- Итерационное обновление состояния до стабилизации или достижения `max-iter`.  
- Сохранение состояния каждые `freq` итераций в BMP:  
  - `0` — белый, `1` — зелёный, `2` — фиолетовый, `3` — жёлтый, `>3` — чёрный.  
- Реализация BMP-записи без сторонних библиотек и контейнеров STL.  
- Консольные аргументы: `--input`, `--output`, `--max-iter`, `--freq`.  


### Лабораторная №4 — Парсер аргументов командной строки

**Цель:**  
Реализовать класс для парсинга аргументов командной строки, обеспечивающий работу со строковыми, целочисленными и булевыми параметрами.

**Содержание:**  
- Проектирование класса `ArgParser`.  
- Поддержка аргументов типов: string, int, bool.  
- Реализация методов: добавление аргументов, парсинг входной строки, получение значений.  
- Обеспечение успешного прохождения всех тестов GoogleTest.  


### Лабораторная №5 — Консольный бот для игры в морской бой

**Цель:**  
Спроектировать и реализовать консольное приложение-бот, играющее в морской бой через стандартные потоки ввода и вывода.

**Содержание:**  
- Реализация двух ролей: `master` и `slave`.  
- Поддержка стандартных команд управления игрой (создание, старт, выстрел, завершение и т.д.).  
- Возможность настройки параметров поля и количества кораблей.  
- Поддержка сохранения (`dump`) и загрузки (`load`) состояния игры.  
- Реализация двух стратегий:  
  - **Ordered** — последовательные выстрелы построчно.  
  - **Custom** — пользовательская стратегия.  
- Архитектурное разделение логики игры и интерфейса ввода/вывода.  
- Подготовка к турниру алгоритмов между реализациями игроков.  


### Лабораторная №6 — Поиск маршрутов с использованием Yandex API

**Цель:**  
Реализовать консольное приложение, которое на заданную дату ищет маршруты из Санкт-Петербурга до вашего родного города (если вы из СПб — до Пскова) и обратно с не более чем одной пересадкой, используя API «Яндекс.Расписания», и уменьшает число внешних запросов за счёт кэша (в памяти и на диске).

**Содержание:**  
- Разработка консольного интерфейса: передача целевой даты (и при необходимости — направления) через аргументы командной строки.  
- Запросы к API «Яндекс.Расписания» для построения маршрутов (учёт возможных комбинаций разных видов транспорта, например самолёт+поезд).  
- Ограничение маршрутов: не более 1 пересадки (т.е. максимум 2 отрезка). Поиск туда и обратно.  
- Кэширование промежуточных и неизменяемых данных в оперативной памяти и на файловой системе (чтобы не превышать лимит API и ускорить повторные запросы).  
- Использование внешних библиотек: C++ Requests для HTTP и nlohmann/json для разбора JSON, ftxui для красивого ввода 
- Обработка ошибок и граничных случаев: ограничение по количеству запросов, таймауты, некорректные ответы API, отсутствие маршрутов и т.п.  
- Корректный и понятный вывод найденных маршрутов в консоль (включая вид транспорта, пересадки, время в пути, пересадочные стыковки).  
- Валидация: предусмотреть проверки на корректность парсинга ответов, поведение при недоступности API и при пустых результатах.


### Лабораторная №7 — STL-совместимый контейнер Unrolled Linked List

**Цель:**  
Реализовать STL-совместимый контейнер `UnrolledLinkedList` с шаблонной параметризацией по типу элементов, размеру ноды и аллокатору, поддерживающий основные методы последовательного контейнера и двунаправленные итераторы.

**Содержание:**  
- Реализация шаблонного контейнера с поддержкой двунаправленного итератора и совместимости с аллокатором.  
- Методы с гарантированной сложностью и обработкой исключений:  
  - `insert` — O(1) для одного элемента, O(M) для M элементов (strong guarantee)  
  - `erase` — O(1) для одного элемента, O(M) для M элементов (noexcept)  
  - `clear` — O(N) (noexcept)  
  - `push_back` / `push_front` — O(1) (strong)  
  - `pop_back` / `pop_front` — O(1) (noexcept)  
- Покрытие всех требований тестами Google Test.  
- Ограничения: нельзя использовать стандартные контейнеры STL.  


### Лабораторная №8 — STL-адаптеры и потоковая обработка данных

**Цель:**  
Разработать библиотеку адаптеров для упрощённой работы с алгоритмами, контейнерами и файлами, обеспечивающую ленивую потоковую обработку данных с константным потреблением памяти (за исключением `AggregateByKey` и `Join`).

**Содержание:**  
- Реализация адаптеров:  
  - **Dir** — перечисление файлов в директории (рекурсивно)  
  - **OpenFiles** — открытие потоков для файлов  
  - **Split** — разбиение потоков по указанным делимитерам  
  - **Out / Write** — вывод данных в поток  
  - **AsDataFlow / AsVector** — преобразование контейнера в поток и сбор в вектор  
  - **Transform / Filter** — изменение и фильтрация элементов  
  - **Join / KV / JoinResult** — объединение потоков по ключу  
  - **DropNullopt / SplitExpected** — фильтрация и разветвление потоков  
  - **AggregateByKey** — агрегация по ключу (не лениво)  
- Поддержка ленивого вычисления, минимальное потребление памяти, совместимость с range-based for.  
- Покрытие всех адаптеров тестами Google Test.  


### Лабораторная №9 — Шедулер задач (TTaskScheduler)

**Цель:**  
Разработать класс `TTaskScheduler`, который позволяет управлять зависимыми задачами и выполнять их с учётом графа вычислений, оптимизируя повторное использование промежуточных результатов.

**Содержание:**  
- Реализация публичного интерфейса:
  - `add` — добавление задачи, возвращает идентификатор задачи  
  - `getFutureResult<T>` — получение результата задачи в будущем  
  - `getResult<T>` — получение результата задачи заданного типа (вычисляется по требованию)  
  - `executeAll` — выполнение всех запланированных задач  
- Поддержка задач с не более чем двумя аргументами, включая указатели на методы класса.  
- Оптимизация вычислений: повторные вычисления промежуточных результатов исключены.  
- Использование идей **Type Erasure**, `std::forward`, категорий значений и семантики перемещения для эффективного управления задачами.  
- Ограничения: использование стандартной библиотеки разрешено только для контейнеров и умных указателей.  
- Покрытие функциональности тестами Google Test.  
